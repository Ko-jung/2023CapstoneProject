직렬화: 어떤 객체가 랜덤 액세스 가능한 형태로 메모리상에 존재할 때, 이를 일련의 여러 비트로 변환하여 길게 나열하는 것.
    어떤 오브젝트 class가 int, char를 가지고 있다면 직렬화는 쉽다.
    하지만 상속을 받고, HomeBase같은 포인터 멤버 변수와 STL vector를 멤버 변수로 가지고 있다면 복잡해진다.
    1. 상속을 받으니 가상 함수 테이블을 가르키는 포인터가 생기고, 2. 어느 객체를 가르키는 포인터의 주소를 그대로 복제되어 쓰이므로 다른 결과가 빚어질 수 있다.
    3. 또한 vector의 메모리 구조상 그대로 복제하여 쓰는순간 100퍼 실패한다고 봐야한다.
    4. 문제는 없지만 이름을 128바이트로 잡고 5바이트만 쓰는것도 불필요한 바이트 차지이다.
    이 책에선 이 예제들로 직렬화 방식을 설명해준다.

스트림: 순서가 있는 데이터 원소의 집합을 캡슐화하여 유저가 그 데이터를 읽거나 쓸 수 있게 해주는 자료구조
    보낼 데이터를 스트림에 담아서 send()를 통해 보낼 예정
    보낼 데이터를 담을 입력 출력 스트림 두 개 구현
    이때 바이트 단위가 아닌 비트 단위로 하여 최소 바이트로 데이터를 보내게 할 수 있음

3를 해결하기 위해,
임베딩: 독립적인 데이터를 다른 데이터 중간에 끼워 넣는 것
    스트림 방식으로만은 포인터나 컨테이너 등 간접 참조 데이터를 직렬화 하지 못한다.
    vector를 직렬화 하려면 vector에 저장된 데이터만 저장하게 끔 커스텀 함수를 만든다.
    스트림에 vector의 데이터 수를 먼저 넣고 데이터를 하나하나 넣는다. 그렇게 되면 꺼낼 때도 개수가 먼저 꺼내지고 데이터가 순차적으로 나온다.
    
2를 해결하기 위해,
링킹: 여러 번 참조 될 법한 객체에 고유 식별자 (또는 ID)를 부여하여 직렬화 할때 오로지 식별자만 직렬화 하는 것
       후에, 식별자에 대응하는 참조 객체를 찾아 연결함.
    임베딩 기법은 다른 객체와 공유되지 않는 데이터에 한해서만 적용할 수 있는 기법. 하나만 있어야 할 객체가 복윈 시 똑같은 내용으로 두 개 만들어질 것이다.
    이후 5장에서 더 자세히 다룰 예정


압축: 네트워크에 부여된 대역폭 내에서 동작할 만큼 효율적인 방식을 위해 데이터를 압축하여 보관함
    희소 배열 압축: 보낼 필요가 없는 정보를 제거, (1을 해결하기 위해)
        이름을 저장할 128바이트 문자 배열이 있을 때, 그 중 5바이트만 쓴다면 123바이트는 보낼 필요가 없다.
        vector와 비슷하게 문자열의 길이와 데이터만 담긴 문자열을 스트림에 담는다.
        사실 문자열을 나타낼땐 std::string을 최적화 관점에서 추천하고 있다.
    엔트로피 인코딩: 데이터 압축에 있어 출현하는 데이터의 예측 가능성 정도가 얼마나 높고 낮은가에 따라 압축률이 달라진다는 이론
        물론 게임 차원에서 CPU 자원을 엔트로피 분석에 쓰는건 비효율적이지만 어느정도 간단한 방법으로 효율적인 엔트로핑 인코딩을 할 수 있는 경우가 있다.
        예를 들어, 좌표를 나타내는 Vector3 자료형이 있을 때, 점프를 거의 안한다고 가정하자.
        그러면 y는 대부분이 0일 것이고 직렬화 할때 bool 값을 통해 y가 0인지 아닌지 구분하게 한다(bool 값은 당연히 스트림에 1비트만 작성된다).
        y==0이면 1비트만 더 쓰고(총 64(x, z좌표) + 1(bool) = 65), 아니라면 y좌표를 기록한다(32 + 32 + 1 + 32 = 97).
        이로써 바닥에 있는 시간이 아닐때보다 더 많을 수록 이득이 커진다.
        하지만 이렇게 계속 코드를 짜기엔 복잡해지므로 개별 필드를 하나하나 최적화 하는 것이 아닌 있는 그대로 직렬화 후,
        허프만 코딩(zip 혹은 zlib, lz4), 산술 코딩, 감마 코딩, RLE 인코딩을 하는 방식을 널리 쓴다.
    고정 소수점: 정수를 미리 정해둔 상수로 나누어 쓰는 숫자
        엔트로피 인코딩 예시에 이어서 x, z 좌표를 최적화 하고 싶다. 월드 크기는 4000 * 4000일 때 x, z는 [-2000, 2000]이 되는 것이다.
        그리고 좌표이동의 정밀값은 0.1이면 충분하다는 결론이 났으므로 x축에 가능한 값의 최대 개수는 (2000 - (-2000)) / 0.1 + 1 = 40001개 이다.
        40001은 16(log40001 = 15.3)개 비트로 표현이 가능하므로 기존 float형 32비트에서 반으로 줄어든 크기로 표현이 가능해졌다.
        그러므로 총 좌표 크기는 16 + 16 + 1 (+ 엔트로피 인코딩 사용 시 y좌표 평균값)이 된다.
    기하 압축: 여러 기하(geometry) 자료형을 압축하는 기법. 이 책에선 사원수와 변환 행렬을 다룸
        사원수로 회전을 표현할 때 정규화하여 [-1, 1]로 만들고 네 성분을 다 제곱하고 더했을시 1이 나온다는 사실을 이용한다.
        3성분을 고정소수점으로 표시하고 1비트를 추가로 적어 4번째 성분의 부호를 나타낸다. 후에 4번째 성분 값은 1 - (세 성분 다 더한 값)으로 구한다
        이때, 고정 소수점으로 표현할 때 약간의 정밀도가 손실되지만 16비트면 납득가능한 수준이다.
        이로써 float형 4개 128비트를 정밀도를 아주 조금 훼손하고 49비트로 직렬화가 가능해진다.
        변환 행렬은 원래 float형 16개로 구성 되지만 아핀 행렬이라면 이동 3, 회전 사원수 1, 스케일 3개로 10개의 float만 사용하면 된다.
        이때 스케일은 1이 아닌 경우가 대부분이라 유니폼(세 성분이 다 같음)인지를 비트로 표기 후 유니폼한 경우 세 성분 중 하나만 직렬화 하면 된다.
        