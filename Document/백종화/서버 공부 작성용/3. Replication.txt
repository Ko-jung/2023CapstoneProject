리플리케이션: 객체의 상태를 한 호스트에서 다른 호스트로 복제 전달하는 행위
    리플리케이션을 위해선 직렬화 뿐만 아니라 호스트가 취해야 할 준비 절차는 다음과 같다
    1. 패킷에 '객체 상태를 담은 패킷'이라 표시
        - 호스트는 객체 리플리케이션 외에 다른 용도로 통신을 사용할 수 있으므로 enum같은 걸 사용해서 패킷의 종류를 구분할 수 있게 한다.
        - 
    2. 리플리케이션할 객체에 고유 식별자 부여
        - 앞서 링킹을 했던것 처럼 수신 호스트가 이미 갖고 있는 객체인지 구분하고 연결하는 과정을 거친다.
        - 그러기 위해 고유 객체 개수를 어림잡아 변수 하나 만들어 두고 이를 통해 식별한다.

    3. 리플리케이션할 객체의 클래스 식별
        - 또한 객체를 수신측에서 생성하기 위해선 객체의 클래스가 뭔지 알 수 있어야한다.
        - 문자 4개를 uint32_t로 캐스팅해서 구분하는 인스턴스를 만들어 스트림으로 전송하는 방식을 택한다.
        - 클래스가 많아지면 송신에서 캐스팅하고 수신에서 switch문으로 걸러내는걸 계속 추가해야하기 때문에 class 내부에
                enum {kClassId = 'GOBJ(GameObject)'}
                같은 방식으로 변수를 추가 구현한다.
        - 그런 후 GetClassId() 매소드를 가상함수로 구현하면 그에 맞는 식별자가 리턴될것이다.
이를 사용하면 모든 호스트가 동일한 객체를 보유할 수 있게된다.

월드 상태 변경
    이제 모든 호스트가 월드의 사본을 가지고 있으므로 매번 전체 월드 상태를 단일 패킷으로 리플리케이션 하지 않아도 된다.
    월드 상태의 변화(델타)를 패킷으로 보내면되는데 크게 3가지 중 하나의 리플리케이션 동작을 한다.
    1. 객체를 생성
        - ClassId를 알아내어 객체 생성

    2. 객체를 갱신
        - 식별자를 확인하여 있으면 갱신내용 적용, 없다면 생성 동작을 받지 못 한것이므로 더미 객체를 만들어 읽은다음 폐기

    3. 객체의 소멸
        - 링킹을 통해 객체를 알아내어 remove
    역시나 이를 구분하기 위해 enum을 만들어준다.

2. 객체 갱신 부분에서 객체의 모든 프로퍼티(속성)을 전송 할 필요는 없을것이다.
이를 위해 속성 열거자를 만들어
enum Properties
{
    MSP_Name = 1 << 0;
    MSP_LegCount = 1 << 1;
    MSP_Health = 1 << 2;
    MSP_MAX = 1 << 3;
}
와 같이 만들고 OR 연산을 통해 변한 속성을 한 번에 정리한다.
이름과 체력이 바뀌었다면 4비트 기준 0101을 통해 직렬화 해야하는 정보를 알려준다.

RPC: 원격 프로시저 호출 (Remote Procedure Call)
    예를 들어 PlaySound라는 함수를 만들어 인자로 string, vector3, float가 필요하다고 하자.
    그것을 원격으로 다른 호스트에서 실행하기 위해선 원하는 인자 값을 보내줘야한다.
    역시나 RPC를 뜻하는 열거자를 만들고 수신측은 RPC에 해당하면 string을 통해 RPCTable에 연결된 Unwrap함수를 실행시킨다.
    후에 스트림에 기록된 인자3개를 차례로 받아 함수를 실행한다.

















