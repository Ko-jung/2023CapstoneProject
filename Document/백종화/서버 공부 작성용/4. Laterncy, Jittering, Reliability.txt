레이턴시: 관측 가능한 사건의 원인이 발생한 후 그 효과가 실제 관측되는 데까지 걸리는 시간
    네트워크가 원인이 아닌 레이턴시:
        입력 샘플링 레이턴시
            - 사용자가 버튼을 누른후 게임이 그것을 감지하는데 걸리는 시간
            - 입력 처리는 프레임이 지나야 검사를 하기 때문에 최대 16ms가 걸릴 수 있다.

        렌더링 파이프라인 레이턴시
            - CPU가 명령을 내리고 GPU가 그 명령을 받아 처리(렌더링)하기까지 걸리는 시간
            - 이 역시 한 프레임이 지나야 그리고 출력하게 된다.

        멀티스레드 렌더링 파이프라인 레이턴시
            - 게임 로직과 렌더 로직을 따로 스레드로 만들어서 구현하는 게임인 경우
            - 로직 -> 렌더 -> GPU에서 렌더 완료 이기 때문에 여기서 레이턴시가 발생 할 수 있다.

        수직 동기화
            - 화면이 갈라진 것처럼 렌더링하는 것을 방지하기 위해 흔히 비디오 카드가 수직 동기화 시간에만 이미지를 표시하게 하는 방식을 흔히 사용한다.
            - 수직 동기화의 주기가 1/60초 정도 하는데 게임에서 소모한 시간이 16ms보다 작다면 문제가 없지만 1ms라도 초과하게되면 그 다음 주기까지 기다려야한다.
            - 그러면 한 프레임의 레이턴시를 경험한다.

        디스플레이 랙
            - 대부분의 HDTV나 LCD 모니터는 출력 전에 소정의 영상 처리를 거친다.
            - 여기서 시간이 걸린다면 그만큼 레이턴시가 있는 것처럼 느낀다.

        픽셀 반응 시간
            - LCD 디스플레이를 구성하는 픽셀의 밝기와 색상이 변하는데도 약간의 시간이 필요하다.
            - 대부분 9ms 이하로 끝나지만 오래된 것들은 더 걸릴지도?

    네트워크 레이턴시
        처리지연
            - 패킷을 처리하는 과정에서 네트워크 장비측에서 발생하는 지연시간.
            - 라우터의 최적 경로 탐색, NAT 네트워크 주소 변환이나 암호화에 들이는 시간이다.
            - 하지만 요즘 출시되는 라우터의 처리 속도가 매우 빨라져서 큰 문제가 되지 않는다.

        전송지연
            - 라우터가 패킷을 전달하기 위해 패킷은 링크 계층 인터페이스를 거친다.
            - 이때 매체에 기록하는 비트 수의 평균 빈도를 조절하는데 1메가비트 이더넷인경우 이더넷 케이블에 초당 백만 개의 비트를 기록할 수 있다.
            - 따라서 1500바이트 패킷을 기록하는데만 12.5ms가 소요된다.
            - 이처럼 물리적 매체에 기록하는데 들이는 시간이다.
            - 사용자가 연결된 링크 계층의 종류에 따라 좌우한다.
            - 인터넷 백본망에 가까울 수록 대역폭이 증가하며 멀어질수록 전송 지연의 정도가 커진다.
            
        큐잉지연
            - 라우터는 한 번에 제한된 양의 패킷만 보낼 수 있는데, 처리 용량보다 많은 패킷이 도착하면 수신 대기열에 보관 후 나중에 처리한다.
            - NIC도 한 번에 한 패킷만 출력되므로 이렇게 대기열에 머무르는 시간을 큐잉 지연이라 한다.
            - 처리 지연과 전송 지연을 최소화하면 자연스럽게 큐잉지연도 최소화 된다.
            - 또한 같은 양이더라도 패킷을 적게 보낼 수록 큐잉지연을 줄일 수 있다.

        전파지연
            - 어떤 물리적 매체도 빛보다 빠르게 보낼 수 없다.
            - 이에따라 미터당 최소 0.3ns가 필요하게 되는데 매체를 타고 전파되는데 필요한 시간이다.
            - 최적화 여지가 많은 편이다. 그냥 서버와 클라 사이의 거리를 좁히면 된다.

지터링: RTT(호스트가 패킷을 발신하여 상대 호스트에 도착한다음 응답 패킷을 다시 받기까지 걸리는 시간, Round Trip Time)의 기댓값으로부터의 편차
    앞의 네트워크 레이턴시 4가지로 인해 발생할 수 있는데, 지터링이 심한경우 패킷의 순서가 바뀌어서 오는 상황이 생길 수 있다.
    따라서 TCP를 쓰거나 UDP라면 패킷 순서를 맞춰주는 사설 시스템을 구축해야 한다.

패킷 손실: 패킷이 목적지까지 도달하는데 시간이 너무 오래걸리거나 아예 도달하지 못한 경우
    물리 매체에 문제발생
        - 데이터 전송은 근본적으로 전자기파 에너지의 전달인데, 외부에 전자기적 간섭이나 신호가 교란됐을 때 일어날 수 있다.

    링크 계층에 문제 발생
        - 링크 계층에는 데이터를 보낼 수 있고 없고에 대한 규칙이 있다.
        - 꽉 차면 보내야할 프레임 일부를 소각하는데 링크 계층은 신뢰성을 보장하지 않으므로 잘못되었다 볼 수 없다.

    네트워크 계층에 문제 발생
        - 라우터가 처리할 수 있는 속도보다 빠르게 패킷이 더 도착하면 대기열에 넣는데 이 대기열이 꽉차면 대기 내 또는 새로운 대기 패킷을 폐기한다.
        - 이때 TCP보다 UDP를 우선으로 폐기하는데 TCP는 폐기해봤자 재전송이 일어난다는 판단하에다.
    
    이런 상황을 피하기위해 구조적으로 패킷 손실을 최소하게 끔 설계하자.
    라우터 하나, 선로 하나 덜 타면 그만큼 확률이 줄어드는 것이고 패킷 개수를 최소한으로 줄여도 효과가 있을 것이다.

만약 UDP로 게임을 만든다고 하면, 신뢰성 매커니즘을 구현해야한다.
이 책에선 패킷에 꼬리표를 달아서 순서를 확인하는 방식을 택한다.
    패킷을 보낼 때마다 시퀀스 번호 꼬리표를 달아 수신측에서 예상 시퀀스 번호와 비교함
    정확히 일치한다면 와야할 패킷이 온것이므로 응답 처리를 해준다.
    받은 번호가 예상 시퀀스 번호보다 작다면 최근 패킷보다 오랜된 것이 온것이다. 오버플로우 되어서 작은건지 판단하고 그렇지 않다면 패킷을 폐기처분하고 잘 왔다는 응답처리를 한다.
    받은 번호가 예상 시퀀스 번호보다 크다면 나중에 발송된것이 먼저 온것이다. 정상적으로 처리하고 예상 시퀀스 번호를 이에 맞춘다.

    하지만 UDP 특정상 정상적으로 처리하고 보낸 응답 패킷이 도달하지 않을 수 있다.
    응답 패킷이 도달하지 않으면 송신측에서 다시 보낼 것이므로 수신측은 받았을 때, 이미 받은건지 처리해야한다.

객체 리플리케이션 신뢰성
    객체를 만들거나 수정하거나 삭제할 때 발생하는 리플리케이션 패킷 또한 신뢰성을 가져야한다.
    이제 게임 시스템에서 리플리케이션 매니저로 패킷을 전송하는 담당을 넘기고 게임 시스템은 넘겨야할 정보를 리플리케이션 매니저에게 알리게 한다.
    그 후 리플리케이션 매니저가 패킷을 보내고 응답이 없다면 전 패킷을 썼던 객체를 다시 알아내어 새로운 정보를 담아 새로 패킷을 작성한다.
    이러한 점은 TCP에서 발전한 방식인데, 오래된 상태 대신 새로운 상태를 보낸다는 점에서 신선도가 살아있다.


