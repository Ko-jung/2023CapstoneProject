이 책에선 스팀웍스 SDK를 이용하여 설명한다.
일단 게임 서비스 플랫폼 관련 코드를 작성하기 전, 게임에 어떻게 붙일지를 고민해야한다.
간단한 버전은 필요한 위치에서 직접 호출하는 방법인데, 이는 추천하지 않는다.
개발자 모두가 스팀웍스를 이해해야 하고, 다른 게임 서비스로 갈아타기가 힘들기 때문이다.
따라서 핌플(Pointer to Implementation, PIMPL)패턴을 쓸 예정이다. 이는 구현 세부사항을 클래스에서 감추기 위해 사용하는 C++의 관용적 용법이다.
	- 핌플 디자인: 헤더 파일에는 실제 구현을 담당하는 클래스를 불완전한 타입으로 선언하고 이에대한 포인터만 원래 클래스에 남겨둔다.
		그 후 소스코드에서 구현 클래스를 정의하는 방법이다.
		이로 인해서 얻는 장점은
  		1. 컴파일 시간 단축 / ABI 호환성 보장
    			내부 구현이 바뀌어도, 헤더만 참조하는 파일은 재 컴파일이 필요하지 않음
  		2. 소스 코드 은닉
    			소스 파일을 빌드해서 배포할 시, 소스 코드를 은닉 가능
		단점은
  		1. 호출 오버헤드
    			포인터를 통해 실제 구현 함수를 호출하게 되므로, 오버헤드가 발생 가능
    			단, 링크 과정에서 최적화되어 없어질 수도 있음.
  		2. 자원 관리 오버헤드
    			자원이 힙에 할당되므로(기존 방식은 스택), 객체 생성시와 소멸 시에 오버헤드가 발생 할 수 있음
그렇게 구현하면 스팀웍스 API 관련 함수들을 모아둔 클래스를 헤더에 포인터로 정의해 둘 수 있고, 후에 플랫폼이 바뀐다면 그에 맞는 클래스를 하나 짜서 연결하면 된다.

X매크로: 파일 한 군데에 정의 내용을 몰아두고 여러 곳에서 각기 다른 문맥으로 인클루드해 재사용하는 것.
	M(a, b) M_##a,
	라고 하면 M(1, 2), M(A, B)가 호출되면
	M_1, M_A로 적용된다.
	+) #define STRING(x)   #x 가 있을 때, STRING(Character) 하면 "Character" 라고 문자열로 정의한것과 마찬가지.
	+) #define  X(n)   x##n 가 있을 때, X(1) 이라고 하면 이는 변수 x1 을 입력한 것과 동일. 즉. ## 연산자는 토큰들을 결합하는 역할.

스팀웍스 SDK 기준으로 셋업, 로비 및 매치메이킹, 네트워킹, 플레이어 통계, 도전과제, 리더보드(순위), DLC등등을 어떻게 하는지 간략하게 설명해준다.
나중에 Steam에 출시할 일이 있을 때 다시 참고해보자.

