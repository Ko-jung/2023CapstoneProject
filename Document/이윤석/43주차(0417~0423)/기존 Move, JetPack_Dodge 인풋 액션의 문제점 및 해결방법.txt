기존의 InputAction은
IMC_Default
ㄴ IA_DefaultGame_Move
ㄴ IA_DefaultGame_Look
ㄴ ...
ㄴ IA_Jetpack_Dodge
ㄴ ...

IMC_Jetpack
ㄴ IA_Jetpack_Hover
ㄴ IA_Jetpack_Dash
의 구조로 되어있었다.

"IA_Jetpack_Dodge" 가 IMC_Default에 있는 이유는
IA_Jetpack_Dodge와 IA_DefaultGame_Move가 모두
W / A / S / D 의 키 값으로 Input Action이 활성화 되는데,

IA_Jetpack_Dodge를 IMC_Jetpack에 추가할 경우
IMC_Default 내 IA_DefaultGame_Move 가 키를 소모하여 IA_Jetpack_Dodge의 액션이 활성화되지 않았기 때문이다.

* 여기서 추가적으로 IMC_Jetpack의 우선순위를 0, IMC_Default의 우선순위를 1로 두어도
직접 제작한 DoubleTab_InputTrigger의 작동 방식이 이전 키의 값이 정상적으로 들어와야 다음 키에서 Double Tab이 정상적으로 작동하는지 확인을 할 수 있는데,
IMC_Default의 우선순위가 낮더라도, IMC_Jetpack에 처음 들어간 W/A/S/D 키는 return ETriggerState::None; 로 인하여 DoubleTab이 작동하지 않는다.
(WASD 움직임 중 WW/AA/SS/DD의 회피가 작동하지 않는다는 의미)

따라서 해당방식을 해결하기 위해
InputTrigger를 활용한 InputAction을 활용하는 EnhancedInput 방식이 아닌,
플레이어 컨트롤러에서 JetpackComponent 소유 유무에 따라
W/A/S/D 키에 대한 직접적인 계산을 하여 함수를 실행시키는 방식으로 변경하기로 하였다.

처음 접근 방식은 
PlayerController에서 IsInputKeyDown(EKeys::W) 의 값을 활용하여 PlayerController 내에서 작업하려 했으나,
EnhancedInput 시스템을 활용하지도 않을 뿐더러,
계속해서 W키를 누르고 있으며 앞으로 갈 때에도 계속해서 Dodge가 실행되는 오류현상이 발생할 것으로 추측되었다.

따라서 다음 접근 방식은
W/A/S/D 총 4개의 키에 대하여 ETriggerEvent::Started / ETriggerEvent::Completed 가 적용된 시간을 계산하는 변수와 함수를 구현하여
이전 키를 뗀(Completed) 시간으로부터 다시 Started 될 때 시간이 0.3초 이내이고,
이 경우 W+W 가 아니라 W- + W- 와 같이 앞으로 가다 멈추고 앞으로 가려고 하는 상황에서도 활성화 될 것이므로
추가적으로 이전키를 입력(Started)한 시간으로부터 다시 Started 될 때 시간이 0.5초 이내로 하게 하여
연속 입력에 대한 처리를 진행하기로 하였다.

* Started로 생각하였으나, W키를 누른채로 D를 누를 경우 Started가 아닌 Triggered가 발생하여 Triggered로 체크하기로 하였다.

다만 위의 방식에서 Vector2D를 활용한 InputValue 값을 사용하면
매 Move Input 마다 계산량이 아주 많으며,
코드를 읽기 불편하여 이전 로직을 제거하고
W/A/S/D 키 각자 하나씩 InputAction을 제작하여 기존 제작한 DoubleTab_InputTrigger을 연결해주었으며
정상적으로 작동됨을 확인하였다.